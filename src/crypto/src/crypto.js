import init, * as kcrypto from "./kestrel_wasm.js";
import { base64Decode, Vec, toBeBytes, toLeBytes } from "./utils.js";
import kwasm from "./kestrel_wasm_bg.wasm";

const wasmData = base64Decode(kwasm);

const CHNUK_SIZE = 65536;
const SCRYPT_N = 32768;
const SCRYPT_R = 8;
const SCRYPT_P = 1;

const PASS_FILE_MAGIC = [0x65, 0x67, 0x6b, 0x20];

/**
 * Kestrel cryptographic functions
 *
 * Exceptions that are throw are instances of new Error with the message
 * from the error included and the name property set to one of:
 *
 * ChaPolyDecryptError
 *
 * EncryptError::UnexpectedData
 * EncryptError::IORead
 * EncryptError::IOWrite
 *
 * DecryptError::ChunkLen
 * DecryptError::ChaPolyDecrypt
 * DecryptError::UnexpectedData
 * DecryptError::IORead
 * DecryptError::IOWrite
 * DecryptError::Other
 *
 * ErrorMessage
 * UnknownError
 * WasmRuntimeError
 *
 * Note the EncryptError and IO portions of DecryptError should not occur
 * because we are reding from Uint8Arrays. This is a holdout from disk io
 * operations in the rust library. ErrorMessage and Unknown should also not
 * occur and are protections against an update to error handling in the
 * underlying library.
 *
 */
export class Crypto {
    /**
     * You must use createInstance()
     */
    constructor() {
    }

    /**
     * Create an instance of the Crypto class
     * @returns An instance of Crypto
     */
    static async createInstance() {
        await init(wasmData);
        return new Crypto();
    }

    /**
     * Scrypt RFC 7914
     *
     * @param {Uint8Array} password Strings will be converted to utf-8
     * @param {Uint8Array} salt Strings will be converted to utf-8
     * @param {Number} n scrypt N (rec. 32768)
     * @param {Number} r scrypt r (rec. 8)
     * @param {Number} p scrypt p (rec. 1)
     * @param {Number} key_len Key length (rec. 32)
     * @returns {Uint8Array} The derived key
     */
    scrypt(password, salt, n, r, p, key_len) {
        let key = kcrypto.scrypt(password, salt, n, r, p, key_len);

        return key;
    }

    /**
     * X25519 RFC 7748
     *
     * @param {Uint8Array} k Private Key
     * @param {Uint8Array} u Public Key
     * @returns {Uint8Array} The derived shared secret
     */
    x25519(k, u) {
        let sharedSecret = kcrypto.x25519(k, u);
        return sharedSecret;
    }

    /**
     * Derive Public Key
     *
     * @param {Uint8Array} privateKey Private Key
     * @returns {Uint8Array} The derived public key
     */
    x25519DerivePublic(privateKey) {
        let publicKey = kcrypto.x25519_derive_public(privateKey);
        return publicKey;
    }

    /**
     * Generate Secure Random Bytes
     *
     * @param {Number} len Number of bytes to generate
     * @returns {Uint8Array} len number of generated bytes
     */
    secureRandom(len) {
        let randomBytes = kcrypto.secure_random(len);
        return randomBytes;
    }

    /**
     * SHA-256
     *
     * @param {Uint8Array} data Data to hash
     * @returns {Uint8Array} SHA-256 hash of the provided data
     */
    sha256(data) {
        let hash = kcrypto.sha256(data);
        return hash;
    }

    /**
     * ChaCha20-Poly1305 RFC 7539
     * @param {Uint8Array} key 32 byte ChaPoly key
     * @param {Uint8Array} nonce 12 byte nonce
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} aad Addtional authenticated data
     * @returns {Uint8Array} Ciphertext
     */
    chapolyEncrypt(key, nonce, plaintext, aad) {
        let ciphertext = kcrypto.chapoly_encrypt_ietf(key, nonce, plaintext, aad);
        return ciphertext;
    }

    /**
     * ChaCha20-Poly1305 RFC 7539
     * @param {Uint8Array} key 32 byte ChaPoly key
     * @param {Uint8Array} nonce 12 byte nonce
     * @param {Uint8Array} ciphertext Ciphertext to decrypt
     * @param {Uint8Array} aad Addtional authenticated data
     * @throws ChaPolyDecryptError
     * @returns {Uint8Array} Plaintext
     */
    chapolyDecrypt(key, nonce, ciphertext, aad) {
        let plaintext;
        try {
            plaintext = kcrypto.chapoly_decrypt_ietf(key, nonce, ciphertext, aad);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }

        return plaintext;
    }

    /**
     * Kestrel encryption using a key derived from a password
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} password Password
     * @param {Uint8Array} salt 32 byte salt
     * @param {Number} [fileFormat=0x20] Password file format version. v1 is 0x20
     * @throws EncryptError
     * @returns {Uint8Array} Ciphertext
     */
    passEncrypt(plaintext, password, salt, fileFormat = 0x20) {
        try {
            const ciphertext = new Vec();
            let key = this.scrypt(password, salt, SCRYPT_N, SCRYPT_R, SCRYPT_P, 32);
            const aad = new Uint8Array(PASS_FILE_MAGIC);

            ciphertext.extend(PASS_FILE_MAGIC);
            ciphertext.extend(salt);

            this.encryptChunks(plaintext, ciphertext, key, aad, CHNUK_SIZE);

            return ciphertext.toBytes();
        } catch (e) {
            const err = this.getError(e);
            throw err;
        }
    }

    /**
     * Kestrel decryption using a key derived from a password
     * @param {Uint8Array} ciphertext Ciphertext to decrypt
     * @param {Uint8Array} password Password
     * @param {Number} [file_format=0x20] Optional password file format version. v1 is 0x20
     * @throws DecryptError
     * @returns {Uint8Array} Plaintext
     */
    passDecrypt(ciphertext, password, fileFormat = 0x20) {
        let plaintext;
        try {
            plaintext = kcrypto.pass_decrypt(ciphertext, password, fileFormat);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }
        return plaintext;
    }

    /**
     * Kestrel encryption using public keys
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} senderPrivateKey Sender  private key
     * @param {Uint8Array} recipientPublicKey Recipient public key
     * @param {Uint8Array} [ephemPrivateKey=new Uint8Array(0)] Optional ephemeral key.
     * @param {Uint8Array} [payloadKey=new Uint8Array(0)] Optional payload key
     * @param {Number} [fileFormat=0x10] Optional key file format version. v1 is 0x10
     * @throws EncryptError
     * @returns {Uint8Array} Ciphertext
     */
    keyEncrypt(plaintext, senderPrivateKey, recipientPublicKey, ephemPrivateKey = new Uint8Array(0), payloadKey = new Uint8Array(0), fileFormat = 0x10) {
        let ciphertext;
        try {
            ciphertext = kcrypto.key_encrypt(plaintext, senderPrivateKey, recipientPublicKey, ephemPrivateKey, payloadKey, fileFormat);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }
        return ciphertext;
    }

    /**
     * Kestrel decryption using public keys
     * @param {Uint8Array} ciphertext Ciphertext to decrypt
     * @param {Uint8Array} recipientPrivateKey Recipient private key
     * @param {Uint8Array} [fileFormat=0x10] Optional key file format version. v1 is 0x10
     * @throws DecryptError
     * @returns {Object} Object with properties: plaintext and publicKey
     */
    keyDecrypt(ciphertext, recipientPrivateKey, fileFormat = 0x10) {
        let plaintext;
        let publicKey;
        try {
            const pubKeyBuf = new Uint8Array(32);
            plaintext = kcrypto.key_decrypt(ciphertext, recipientPrivateKey, fileFormat, pubKeyBuf);
            publicKey = pubKeyBuf;
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }

        return {
            plaintext: plaintext,
            publicKey: publicKey
        };
    }

    getError(wasmError) {
        if (typeof wasmError !== "string") {
            if (wasmError instanceof WebAssembly.RuntimeError) {
                const ex = new Error("Wasm crashed. Input file is likely too large.");
                ex.name = "WasmRuntimeError";
                return ex;
            } else if (wasmError instanceof Error) {
                return wasmError;
            } else {
                const ex = new Error("Unknown crypto error");
                ex.name = "UnknownError";
                return ex;
            }
        }
        let sepIdx = wasmError.indexOf(";");
        if (sepIdx < 1) {
            return new Error(wasmError.toString());
        } else {
            let name = wasmError.slice(0, sepIdx);
            let msg = wasmError.slice(sepIdx+1, wasmError.length);
            msg = msg.trim();
            if (name == "UnknownError" || name == "ErrorMessage") {
                const ex = new Error("Crypto error");
                return ex;
            } else {
                const ex = new Error(msg);
                ex.name = name;
                return ex;
            }
        }
    }

    encryptChunks(plaintext, ciphertext, key, aad, chunkSize) {
        // @@SECURITY: In the rust impelmentation chunk number is a 64 bit
        // type. We're going to use 32 bits here because a JavaScript number
        // can't hold a 64 bit integer and we don't want to mess with BigInt.
        // This reduces the maximum amount of data that can be encrypted in a
        // sigle file to ~256TB
        let chunkNumber = 0;
        let done = false;
        let ptOffset = 0;
        let prev = read(plaintext, ptOffset, chunkSize);
        let prevSize = prev.size();
        ptOffset += prevSize;
        if (prevSize < chunkSize) {
            done = true;
        }

        while (true) {
            let buf = read(plaintext, ptOffset, chunkSize);
            const bufSize = buf.size();
            if (bufSize != 0 && done) {
                throw new Error("Read unexpected data");
            } else if (bufSize == 0) {
                done = true;
            }

            let lastChunkIndicator = 0;
            if (done) {
                lastChunkIndicator = 1;
            }
            const lastChunkIndicatorBytes = toBeBytes(lastChunkIndicator);
            let ciphertextLen = prevSize;
            const ciphertextLenBytes = toBeBytes(ciphertextLen);
            let authData = new Vec();
            authData.extend(aad);
            authData.extend(lastChunkIndicatorBytes);
            authData.extend(ciphertextLenBytes);
 
            const nonce = new Vec();
            nonce.extend([0x00, 0x00, 0x00, 0x00]);
            nonce.extend(toLeBytes(chunkNumber));
            nonce.extend([0x00, 0x00, 0x00, 0x00]);
            const ct = this.chapolyEncrypt(key, nonce.toBytes(), prev.toBytes(), authData.toBytes());

            const chunkHeader = new Vec();
            chunkHeader.extend([0x00, 0x00, 0x00, 0x00]);
            chunkHeader.extend(toBeBytes(chunkNumber));
            chunkHeader.extend(lastChunkIndicatorBytes);
            chunkHeader.extend(ciphertextLenBytes);

            ciphertext.extend(chunkHeader.toBytes());
            ciphertext.extend(ct);

            if (done) {
                break;
            }

            prev = new Vec();
            prev.extend(buf.toBytes());
            prevSize = bufSize;
            ptOffset += prevSize;

            // @@SECURITY: It is extremely important that chunk number
            // increase sequentially by one here.
            chunkNumber += 1;
        }
    }
}

function read(source, offset, count) {
    const sourceLen = source.length - offset;
    const maxLen = Math.min(sourceLen, count);
    const dest = new Vec();
    for (let i = offset; i < maxLen + offset; i++) {
        dest.push(source[i]);
    }

    return dest;
}
