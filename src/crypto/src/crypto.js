import init, * as kcrypto from "./kestrel_wasm.js";
import { base64Decode } from "./utils.js";
import kwasm from "./kestrel_wasm_bg.wasm";

const wasmData = base64Decode(kwasm);

/**
 * Kestrel cryptographic functions
 *
 * Exceptions that are throw are instances of new Error with the message
 * from the error included and the name property set to one of:
 *
 * ChaPolyDecryptError
 *
 * EncryptError::UnexpectedData
 * EncryptError::IORead
 * EncryptError::IOWrite
 *
 * DecryptError::ChunkLen
 * DecryptError::ChaPolyDecrypt
 * DecryptError::UnexpectedData
 * DecryptError::IORead
 * DecryptError::IOWrite
 * DecryptError::Other
 *
 * Note the EncryptError and IO portions of DecryptError should not occur
 * because we are reding from Uint8Arrays. This is a holdout from disk io
 * operations in the rust library. ErrorMessage and Unknown should also not
 * occur and are protections against an update to error handling in the
 * underlying library.
 *
 */
export class Crypto {
    /**
     * You must use createInstance()
     */
    constructor() {
    }

    /**
     * Create an instance of the Crypto class
     * @returns An instance of Crypto
     */
    static async createInstance() {
        await init(wasmData);
        return new Crypto();
    }

    /**
     * Scrypt RFC 7914
     *
     * @param {Uint8Array} password Strings will be converted to utf-8
     * @param {Uint8Array} salt Strings will be converted to utf-8
     * @param {Number} n scrypt N (rec. 32768)
     * @param {Number} r scrypt r (rec. 8)
     * @param {Number} p scrypt p (rec. 1)
     * @param {Number} key_len Key length (rec. 32)
     * @returns {Uint8Array} The derived key
     */
    scrypt(password, salt, n, r, p, key_len) {
        let key = kcrypto.scrypt(password, salt, n, r, p, key_len);

        return key;
    }

    /**
     * X25519 RFC 7748
     *
     * @param {Uint8Array} k Private Key
     * @param {Uint8Array} u Public Key
     * @returns {Uint8Array} The derived shared secret
     */
    x25519(k, u) {
        let sharedSecret = kcrypto.x25519(k, u);
        return sharedSecret;
    }

    /**
     * Derive Public Key
     *
     * @param {Uint8Array} privateKey Private Key
     * @returns {Uint8Array} The derived public key
     */
    x25519DerivePublic(privateKey) {
        let publicKey = kcrypto.x25519_derive_public(privateKey);
        return publicKey;
    }

    /**
     * Generate Secure Random Bytes
     *
     * @param {Number} len Number of bytes to generate
     * @returns {Uint8Array} len number of generated bytes
     */
    secureRandom(len) {
        let randomBytes = kcrypto.secure_random(len);
        return randomBytes;
    }

    /**
     * SHA-256
     *
     * @param {Uint8Array} data Data to hash
     * @returns {Uint8Array} SHA-256 hash of the provided data
     */
    sha256(data) {
        let hash = kcrypto.sha256(data);
        return hash;
    }

    /**
     * ChaCha20-Poly1305 RFC 7539
     * @param {Uint8Array} key 32 byte ChaPoly key
     * @param {Uint8Array} nonce 12 byte nonce
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} aad Addtional authenticated data
     * @returns {Uint8Array} Ciphertext
     */
    chapolyEncrypt(key, nonce, plaintext, aad) {
        let ciphertext = kcrypto.chapoly_encrypt_ietf(key, nonce, plaintext, aad);
        return ciphertext;
    }

    /**
     * ChaCha20-Poly1305 RFC 7539
     * @param {Uint8Array} key 32 byte ChaPoly key
     * @param {Uint8Array} nonce 12 byte nonce
     * @param {Uint8Array} ciphertext Ciphertext to decrypt
     * @param {Uint8Array} aad Addtional authenticated data
     * @throws ChaPolyDecryptError
     * @returns {Uint8Array} Plaintext
     */
    chapolyDecrypt(key, nonce, ciphertext, aad) {
        let plaintext;
        try {
            plaintext = kcrypto.chapoly_decrypt_ietf(key, nonce, ciphertext, aad);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }

        return plaintext;
    }

    /**
     * Kestrel encryption using a key derived from a password
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} password Password
     * @param {Uint8Array} salt 32 byte salt
     * @param {Number} [file_format=0x20] Password file format version. v1 is 0x20
     * @throws EncryptError
     * @returns {Uint8Array} Ciphertext
     */
    passEncrypt(plaintext, password, salt, file_format = 0x20) {
        let ciphertext;
        try {
            ciphertext = kcrypto.pass_encrypt(plaintext, password, salt, file_format);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }
        return ciphertext;
    }

    /**
     * Kestrel decryption using a key derived from a password
     * @param {Uint8Array} ciphertext Ciphertext to decrypt
     * @param {Uint8Array} password Password
     * @param {Number} [file_format=0x20] Optional password file format version. v1 is 0x20
     * @throws DecryptError
     * @returns {Uint8Array} Plaintext
     */
    passDecrypt(ciphertext, password, file_format = 0x20) {
        let plaintext;
        try {
            plaintext = kcrypto.pass_decrypt(ciphertext, password, file_format);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }
        return plaintext;
    }

    /**
     * Kestrel encryption using public keys
     * @param {Uint8Array} plaintext Plaintext to encrypt
     * @param {Uint8Array} senderPrivateKey Sender  private key
     * @param {Uint8Array} recipientPublicKey Recipient publick ey
     * @param {Uint8Array} [ephemPrivateKey] Optional ephemeral key.
     * @param {Uint8Array} [payloadKey] Optional payload key
     * @param {Number} [fileFormat=0x10] Optional key file format version. v1 is 0x10
     * @throws EncryptError
     * @returns {Uint8Array} Ciphertext
     */
    keyEncrypt(plaintext, senderPrivateKey, recipientPublicKey, ephemPrivateKey, payloadKey, fileFormat = 0x10) {
        let ciphertext;
        try {
            ciphertext = kcrypto.key_encrypt(plaintext, senderPrivateKey, recipientPublicKey, ephemPrivateKey, payloadKey, fileFormat);
        } catch (wasmError) {
            let err = this.getError(wasmError);
            throw err;
        }
        return ciphertext;
    }

    /**
     * Kestrel decryption using public keys
     * @param {*} ciphertext Ciphertext to decrypt
     * @param {*} recipientPrivateKey Recipient private key
     * @param {*} fileFormat Optional key file format version. v1 is 0x10
     * @throws DecryptError
     * @returns {Object} Plaintext and sender public key
     */
    keyDecrypt(ciphertext, recipientPrivateKey, fileFormat = 0x20) {
        let plaintext;
        let publicKey;
        try {
            const pubKeyBuf = new Uint8Array(32);
            plaintext = kcrypto.key_decrypt(ciphertext, recipientPrivateKey, fileFormat, pubKeyBuf);
            publicKey = pubKeyBuf;
        } catch (wasError) {
            let err = this.getError(wasmError);
            throw err;
        }

        return {
            plaintext: plaintext,
            publicKey: publicKey
        };
    }

    getError(wasmError) {
        let sepIdx = wasmError.indexOf(";");
        if (sepIdx < 1) {
            return new Error(wasmError.toString());
        } else {
            let name = wasmError.slice(0, sepIdx);
            let msg = wasmError.slice(sepIdx+1, wasmError.length);
            msg = msg.trim();
            if (name == "Unknown" || name == "ErrorMessage") {
                const ex = new Error("Crypto error");
                return ex;
            } else {
                const ex = new Error(msg);
                ex.name = name;
                return ex;
            }
        }
    }
}
